question_type,language,problem_statement,sample_code,expected_output,test_cases,scoring_criteria,common_mistakes
"Array Sum","Python","Write a function that takes a list of numbers and returns their sum","def sum_numbers(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total","sum_numbers([1,2,3,4,5]) should return 15","[1,2,3,4,5] -> 15\n[0] -> 0\n[-1,1] -> 0\n[] -> 0","Function works correctly: 100%\nMinor syntax issues: 90%\nLogic errors: 70%\nWrong approach: 50%\nNo meaningful code: 25%","Missing return statement, wrong variable names, infinite loops"
"Array Sum","Java","Write a method that takes an array of integers and returns their sum","public static int sumNumbers(int[] numbers) {\n    int total = 0;\n    for (int num : numbers) {\n        total += num;\n    }\n    return total;\n}","sumNumbers({1,2,3,4,5}) should return 15","{1,2,3,4,5} -> 15\n{0} -> 0\n{-1,1} -> 0\n{} -> 0","Correct method: 100%\nMinor syntax issues: 90%\nLogic errors: 70%\nWrong approach: 50%","Missing return statement, wrong loop syntax, array bounds"
"Array Sum","C","Write a function that takes an array and its size, returns sum","int sum_numbers(int arr[], int size) {\n    int total = 0;\n    for (int i = 0; i < size; i++) {\n        total += arr[i];\n    }\n    return total;\n}","sum_numbers({1,2,3,4,5}, 5) should return 15","{1,2,3,4,5}, 5 -> 15\n{0}, 1 -> 0\n{-1,1}, 2 -> 0\n{}, 0 -> 0","Correct function: 100%\nMinor syntax issues: 90%\nLogic errors: 70%\nWrong approach: 50%","Missing size parameter, array bounds errors, wrong loop"
"Array Sum","C++","Write a function that takes a vector and returns sum","int sum_numbers(vector<int>& numbers) {\n    int total = 0;\n    for (int num : numbers) {\n        total += num;\n    }\n    return total;\n}","sum_numbers({1,2,3,4,5}) should return 15","{1,2,3,4,5} -> 15\n{0} -> 0\n{-1,1} -> 0\n{} -> 0","Correct function: 100%\nMinor syntax issues: 90%\nLogic errors: 70%\nWrong approach: 50%","Missing vector include, wrong reference syntax, loop errors"
"Factorial","Python","Write a recursive function to calculate factorial","def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n-1)","factorial(5) should return 120","5 -> 120\n1 -> 1\n0 -> 1","Correct recursion: 100%\nIterative solution: 90%\nOff-by-one errors: 70%\nInfinite recursion: 25%","Missing base case, wrong recursive call, stack overflow"
"Factorial","Java","Write a recursive method to calculate factorial","public static int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    return n * factorial(n-1);\n}","factorial(5) should return 120","5 -> 120\n1 -> 1\n0 -> 1","Correct recursion: 100%\nIterative solution: 90%\nOff-by-one errors: 70%\nInfinite recursion: 25%","Missing base case, wrong recursive call, stack overflow"
"Binary Search","Python","Implement binary search on sorted array","def binary_search(arr, target):\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1","binary_search([1,3,5,7,9], 5) should return 2","[1,3,5,7,9], 5 -> 2\n[1,3,5,7,9], 4 -> -1\n[], 1 -> -1","Correct algorithm: 100%\nOff-by-one errors: 90%\nWrong bounds: 70%\nLinear search: 50%","Infinite loops, wrong mid calculation, bounds errors"
"Binary Search","C++","Implement binary search on sorted vector","int binary_search(vector<int>& arr, int target) {\n    int left = 0, right = arr.size()-1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (arr[mid] == target)\n            return mid;\n        else if (arr[mid] < target)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n    return -1;\n}","binary_search({1,3,5,7,9}, 5) should return 2","{1,3,5,7,9}, 5 -> 2\n{1,3,5,7,9}, 4 -> -1\n{}, 1 -> -1","Correct algorithm: 100%\nOff-by-one errors: 90%\nWrong bounds: 70%\nLinear search: 50%","Missing vector include, infinite loops, wrong mid calculation"
"Class Definition","Java","Create a simple Person class with name and age","public class Person {\n    private String name;\n    private int age;\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() { return name; }\n    public int getAge() { return age; }\n}","Person p = new Person('John', 25); p.getName() returns 'John'","Person('John', 25) -> name='John', age=25\nPerson('Jane', 30) -> name='Jane', age=30","Correct class: 100%\nMissing constructor: 80%\nMissing getters: 70%\nWrong syntax: 50%","Missing private fields, wrong constructor syntax, missing getters"
"Memory Allocation","C","Write a function to allocate and initialize an array","int* create_array(int size) {\n    int* arr = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        arr[i] = 0;\n    }\n    return arr;\n}","create_array(5) returns pointer to array of 5 zeros","5 -> array of 5 zeros\n0 -> NULL or empty array\n10 -> array of 10 zeros","Correct allocation: 100%\nMissing initialization: 90%\nWrong malloc syntax: 70%\nMemory leaks: 50%","Missing malloc, wrong sizeof, no initialization, memory leaks"
"Null Handling","Java","Given an array of Integers, return the sum while safely handling null entries","public static int safeSum(Integer[] arr) {\n    int sum = 0;\n    if (arr == null) return 0;\n    for (Integer x : arr) {\n        if (x != null) sum += x;\n    }\n    return sum;\n}","safeSum(new Integer[]{1,null,2}) should return 3","{1,null,2} -> 3\n{} -> 0\nnull -> 0","Correct null handling: 100%\nMinor issues (enhanced for): 90%\nNull checks missing: 70%\nNPE present: 25%","NullPointerException, missing null guard, unboxed int[] vs Integer[]"
"Pointer Safety","C","Copy a C-string safely into a destination buffer with size parameter","int safe_copy(char* dst, size_t dst_size, const char* src) {\n    if (!dst || !src || dst_size == 0) return -1;\n    size_t i = 0;\n    for (; i + 1 < dst_size && src[i] != '\\0'; ++i) dst[i] = src[i];\n    dst[i] = '\\0';\n    return (int)i;\n}","safe_copy(dst, 5, ""hello"") writes 'hell\\0'","dst_size=5, src=hello -> hell\\0\ninvalid args -> -1","Bounds respected: 100%\nOff-by-one: 90%\nNo terminator: 60%\nIgnores size: 25%","Buffer overflow, missing null terminator, not checking pointers"
"Time Complexity Refactor","C++","Determine the time complexity of nested loops and refactor to O(n)","int countPairs(const vector<int>& a) {\n    int n = (int)a.size();\n    int cnt = 0;\n    unordered_map<int,int> seen;\n    for (int x : a) cnt += seen[x]++;\n    return cnt;\n}","Original O(n^2) refactored to O(n)","[1,1,1] -> 3\n[1,2,1,2] -> 2","Correct O(n): 100%\nMinor map misuse: 90%\nKeeps O(n^2): 50%\nWrong counting: 40%","Double loop O(n^2), misuse of unordered_map, integer overflow"
"Input Validation","Python","Validate and parse integer input; return None for invalid values","def parse_int(s: str):\n    try:\n        s = s.strip()\n        if s.lower().startswith(('0x','-0x')):\n            return int(s, 16)\n        return int(s)\n    except Exception:\n        return None","parse_int(' 42 ') -> 42; parse_int('abc') -> None","'42' -> 42\n'  -7' -> -7\n'abc' -> None","All valid forms handled: 100%\nHex only missing: 90%\nWhitespace issues: 80%\nNo try/except: 25%","Missing strip, not handling bases, ValueError not caught"
"String Immutability","Java","Return a new sanitized string without modifying the original","public static String sanitize(String s) {\n    if (s == null) return """""";\n    return s.replace(""<"", ""&lt;"").replace("">"", ""&gt;"");\n}","sanitize(""<tag>"") -> ""&lt;tag&gt;""","""<tag>"" -> ""&lt;tag&gt;""\nnull -> """"","Pure function: 100%\nPartial escaping: 80%\nMutates input (impossible): 60%\nWrong API: 40%","Forgetting to escape both sides, assuming in-place mutation, NPE without null check"
"Recursion Limits","Python","Compute factorial iteratively to avoid recursion depth issues","def fact(n: int) -> int:\n    if n < 0: return 0\n    ans = 1\n    for i in range(2, n+1):\n        ans *= i\n    return ans","fact(5) -> 120; fact(0) -> 0 or 1 depending spec","5 -> 120\n0 -> 1\n-1 -> 0","Iterative correct: 100%\nRecursive ok but deep risk: 90%\nOff-by-one: 70%\nWrong negatives: 40%","Stack overflow risk, wrong base, negative handling"
"Resource Management","C++","Use RAII to manage file resources and avoid leaks","string readFirstLine(const string& path) {\n    ifstream f(path);\n    if (!f) return """";\n    string line;\n    getline(f, line);\n    return line;\n}","Returns first line or empty string if open fails","'file.txt' -> first line\n'missing' -> ''","RAII OK: 100%\nManual new/delete: 60%\nNo fail check: 50%","Forgetting to check f, manual allocation, not closing file (pre-RAII)"
"Linked List Operations","Python","Implement a function to reverse a singly linked list","class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef reverse_list(head):\n    prev = None\n    current = head\n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    return prev","reverse_list(1->2->3) returns 3->2->1","1->2->3 -> 3->2->1\nNone -> None\n1 -> 1","Correct reversal: 100%\nOff-by-one: 90%\nLosing nodes: 60%\nWrong approach: 40%","Losing references, not updating prev, infinite loop"
"Stack Implementation","Java","Implement a stack using an array with push, pop, and peek operations","public class Stack {\n    private int[] arr;\n    private int top;\n    private int capacity;\n    \n    public Stack(int size) {\n        arr = new int[size];\n        capacity = size;\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < capacity - 1) arr[++top] = x;\n    }\n    \n    public int pop() {\n        if (top >= 0) return arr[top--];\n        return -1;\n    }\n    \n    public int peek() {\n        return top >= 0 ? arr[top] : -1;\n    }\n}","push(5), push(3), pop() returns 3","push(1), push(2), pop() -> 2\npush(5), peek() -> 5","Full implementation: 100%\nMissing overflow check: 90%\nWrong top management: 70%\nNo underflow check: 60%","Array overflow, wrong top index, not checking empty"
"Queue Implementation","C++","Implement a circular queue using an array","class CircularQueue {\nprivate:\n    int* arr;\n    int front, rear, size, capacity;\npublic:\n    CircularQueue(int k) {\n        arr = new int[k];\n        capacity = k;\n        front = rear = -1;\n        size = 0;\n    }\n    \n    bool enqueue(int value) {\n        if (size == capacity) return false;\n        if (front == -1) front = 0;\n        rear = (rear + 1) % capacity;\n        arr[rear] = value;\n        size++;\n        return true;\n    }\n    \n    bool dequeue() {\n        if (size == 0) return false;\n        front = (front + 1) % capacity;\n        size--;\n        return true;\n    }\n}","enqueue(1), enqueue(2), dequeue() removes 1","enqueue(1), dequeue() -> true\nfull queue -> false","Circular logic correct: 100%\nLinear queue: 80%\nBounds errors: 60%\nMemory leaks: 40%","Not using modulo, wrong front/rear, memory leaks"
"Hash Map Implementation","Python","Implement a simple hash map with put, get, and remove operations","class HashMap:\n    def __init__(self, size=100):\n        self.size = size\n        self.buckets = [[] for _ in range(size)]\n    \n    def _hash(self, key):\n        return hash(key) % self.size\n    \n    def put(self, key, value):\n        idx = self._hash(key)\n        for i, (k, v) in enumerate(self.buckets[idx]):\n            if k == key:\n                self.buckets[idx][i] = (key, value)\n                return\n        self.buckets[idx].append((key, value))\n    \n    def get(self, key):\n        idx = self._hash(key)\n        for k, v in self.buckets[idx]:\n            if k == key:\n                return v\n        return None","put('a', 1), get('a') returns 1","put('x', 5), get('x') -> 5\nget('missing') -> None","Full implementation: 100%\nNo collision handling: 70%\nWrong hash: 60%\nNo chaining: 50%","No collision resolution, wrong hash function, not handling duplicates"
"Bubble Sort","Java","Implement bubble sort algorithm","public static void bubbleSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}","bubbleSort([5,2,8,1]) sorts to [1,2,5,8]","[5,2,8,1] -> [1,2,5,8]\n[1] -> [1]\n[] -> []","Correct sort: 100%\nOff-by-one: 90%\nWrong swap: 70%\nWrong bounds: 60%","Array bounds error, wrong comparison, not swapping"
"Merge Sort","C++","Implement merge sort algorithm","void merge(vector<int>& arr, int l, int m, int r) {\n    vector<int> left(arr.begin()+l, arr.begin()+m+1);\n    vector<int> right(arr.begin()+m+1, arr.begin()+r+1);\n    int i = 0, j = 0, k = l;\n    while (i < left.size() && j < right.size())\n        arr[k++] = (left[i] <= right[j]) ? left[i++] : right[j++];\n    while (i < left.size()) arr[k++] = left[i++];\n    while (j < right.size()) arr[k++] = right[j++];\n}\n\nvoid mergeSort(vector<int>& arr, int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}","mergeSort([5,2,8,1], 0, 3) sorts to [1,2,5,8]","[5,2,8,1] -> [1,2,5,8]\n[1] -> [1]\n[] -> []","Correct merge sort: 100%\nMinor merge issues: 90%\nWrong bounds: 70%\nNo divide: 50%","Wrong merge logic, bounds errors, not dividing properly"
"Quick Sort","Python","Implement quick sort using last element as pivot","def partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef quick_sort(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)\n        quick_sort(arr, low, pi - 1)\n        quick_sort(arr, pi + 1, high)","quick_sort([5,2,8,1], 0, 3) sorts to [1,2,5,8]","[5,2,8,1] -> [1,2,5,8]\n[1] -> [1]\n[] -> []","Correct quick sort: 100%\nWrong pivot selection: 90%\nPartition errors: 70%\nInfinite recursion: 40%","Wrong partition logic, bounds errors, pivot not placed correctly"
"Binary Tree Traversal","Java","Implement inorder traversal of binary tree","class TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int x) { val = x; }\n}\n\npublic static void inorder(TreeNode root) {\n    if (root == null) return;\n    inorder(root.left);\n    System.out.print(root.val + "" "");\n    inorder(root.right);\n}","inorder(tree) prints nodes in left-root-right order","Tree: 2(1,3) -> ""1 2 3""\nTree: 1(null,2) -> ""1 2""","Correct traversal: 100%\nWrong order: 80%\nMissing null check: 60%\nNot recursive: 50%","Wrong traversal order, missing null check, stack overflow"
"Graph BFS","C++","Implement breadth-first search for graph","void bfs(vector<vector<int>>& graph, int start) {\n    int n = graph.size();\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n    \n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        cout << node << "" "";\n        \n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n}","bfs(graph, 0) visits nodes level by level","Graph: 0->[1,2], 1->[3] -> ""0 1 2 3""","Correct BFS: 100%\nUsing DFS instead: 70%\nMissing visited: 50%\nWrong queue usage: 40%","Not using queue, missing visited array, infinite loop"
"Graph DFS","Python","Implement depth-first search for graph recursively","def dfs(graph, node, visited=None):\n    if visited is None:\n        visited = set()\n    \n    visited.add(node)\n    print(node, end="" "")\n    \n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n    \n    return visited","dfs(graph, 0) visits nodes depth-first","Graph: {0:[1,2], 1:[3]} -> ""0 1 3 2""","Correct DFS: 100%\nUsing BFS instead: 70%\nMissing visited: 50%\nNot recursive: 60%","Not tracking visited, infinite recursion, wrong traversal"
"Dynamic Programming - Fibonacci","Java","Implement fibonacci using memoization","public static int fib(int n, int[] memo) {\n    if (n <= 1) return n;\n    if (memo[n] != 0) return memo[n];\n    memo[n] = fib(n-1, memo) + fib(n-2, memo);\n    return memo[n];\n}\n\npublic static int fibonacci(int n) {\n    return fib(n, new int[n+1]);\n}","fibonacci(5) returns 5","5 -> 5\n10 -> 55\n0 -> 0","Memoization used: 100%\nIterative DP: 95%\nPlain recursion: 60%\nWrong logic: 40%","No memoization, exponential time, wrong base cases"
"String Reversal","C","Reverse a string in-place without extra space","void reverse_string(char* str) {\n    if (!str) return;\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        char temp = str[i];\n        str[i] = str[len - 1 - i];\n        str[len - 1 - i] = temp;\n    }\n}","reverse_string(""hello"") changes to ""olleh""","""hello"" -> ""olleh""\n""a"" -> ""a""\n"""" -> """"","In-place correct: 100%\nUsing extra space: 80%\nBounds errors: 60%\nNull not handled: 50%","Buffer overflow, wrong indices, using extra space"
"Palindrome Check","Python","Check if a string is a palindrome ignoring case and spaces","def is_palindrome(s):\n    cleaned = ''.join(c.lower() for c in s if c.isalnum())\n    return cleaned == cleaned[::-1]","is_palindrome(""A man a plan"") returns False","""racecar"" -> True\n""hello"" -> False\n""A man, a plan"" -> False","Correct with cleaning: 100%\nCase-sensitive: 80%\nNo cleaning: 70%\nWrong logic: 50%","Not ignoring spaces/case, wrong comparison, not handling punctuation"
"Two Sum Problem","Java","Find two indices that sum to target","public static int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] {map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    return new int[] {-1, -1};\n}","twoSum([2,7,11,15], 9) returns [0,1]","[2,7,11,15], 9 -> [0,1]\n[3,3], 6 -> [0,1]","Hash map O(n): 100%\nNested loops O(n^2): 70%\nWrong logic: 50%\nNo solution: 40%","Using nested loops, wrong indices, not handling duplicates"
"SQL Query - Join","SQL","Write a query to join employees and departments tables","SELECT e.name, e.salary, d.dept_name\nFROM employees e\nINNER JOIN departments d\nON e.dept_id = d.id\nWHERE e.salary > 50000\nORDER BY e.salary DESC;","Returns employees with salary > 50000 and their department","Returns all matching records sorted by salary","Correct JOIN: 100%\nWrong JOIN type: 80%\nMissing WHERE: 70%\nNo ORDER BY: 90%","Using wrong JOIN, missing ON clause, syntax errors"
"SQL Query - Aggregation","SQL","Find average salary by department","SELECT d.dept_name, AVG(e.salary) as avg_salary, COUNT(*) as emp_count\nFROM employees e\nINNER JOIN departments d ON e.dept_id = d.id\nGROUP BY d.dept_name\nHAVING AVG(e.salary) > 60000\nORDER BY avg_salary DESC;","Returns departments with average salary > 60000","Aggregates by department with filtering","Correct aggregation: 100%\nMissing GROUP BY: 70%\nWrong HAVING: 80%\nNo JOIN: 60%","Not grouping, using WHERE instead of HAVING, syntax errors"
"Database Normalization","SQL","Normalize a table to 3NF by creating separate tables","-- Original: Orders(order_id, customer_name, customer_email, product_name, price)\n\nCREATE TABLE Customers (\n    customer_id INT PRIMARY KEY,\n    name VARCHAR(100),\n    email VARCHAR(100)\n);\n\nCREATE TABLE Products (\n    product_id INT PRIMARY KEY,\n    name VARCHAR(100),\n    price DECIMAL(10,2)\n);\n\nCREATE TABLE Orders (\n    order_id INT PRIMARY KEY,\n    customer_id INT,\n    product_id INT,\n    FOREIGN KEY (customer_id) REFERENCES Customers(customer_id),\n    FOREIGN KEY (product_id) REFERENCES Products(product_id)\n);","Creates three tables with proper foreign keys","Removes redundancy and ensures 3NF","3NF achieved: 100%\n2NF only: 80%\nPartial normalization: 60%\nNo normalization: 30%","Not identifying dependencies, missing foreign keys, wrong structure"
"API Design - RESTful","Python","Design a RESTful API endpoint to get user by ID","from flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route('/api/users/<int:user_id>', methods=['GET'])\ndef get_user(user_id):\n    # Database query here\n    user = db.get_user(user_id)\n    if user:\n        return jsonify(user), 200\n    return jsonify({'error': 'User not found'}), 404","GET /api/users/1 returns user with ID 1","Returns user JSON or 404","RESTful design: 100%\nWrong HTTP method: 80%\nNo error handling: 70%\nWrong status codes: 60%","Using wrong HTTP method, not handling errors, wrong URL structure"
"Exception Handling","Java","Implement safe file reading with proper exception handling","public static String readFile(String path) {\n    StringBuilder content = new StringBuilder();\n    try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n        String line;\n        while ((line = br.readLine()) != null) {\n            content.append(line).append(""\n"");\n        }\n    } catch (FileNotFoundException e) {\n        System.err.println(""File not found: "" + path);\n        return null;\n    } catch (IOException e) {\n        System.err.println(""Error reading file: "" + e.getMessage());\n        return null;\n    }\n    return content.toString();\n}","readFile(""test.txt"") returns content or null","Returns file content or handles errors","Try-with-resources: 100%\nManual close: 90%\nNo exception handling: 50%\nResource leak: 30%","Not closing file, catching generic Exception, resource leaks"
"Thread Safety","Java","Implement a thread-safe counter using synchronization","public class Counter {\n    private int count = 0;\n    \n    public synchronized void increment() {\n        count++;\n    }\n    \n    public synchronized int getCount() {\n        return count;\n    }\n}","Multiple threads can safely increment counter","10 threads increment 100 times -> 1000","Synchronized methods: 100%\nAtomic types: 95%\nNo synchronization: 40%\nRace conditions: 20%","Race conditions, not synchronized, data corruption"
"Multithreading","Python","Create threads to process tasks concurrently","import threading\n\ndef process_task(task_id):\n    print(f""Processing task {task_id}"")\n    # Do work here\n\nthreads = []\nfor i in range(5):\n    thread = threading.Thread(target=process_task, args=(i,))\n    threads.append(thread)\n    thread.start()\n\nfor thread in threads:\n    thread.join()","Creates 5 threads and waits for completion","5 tasks processed concurrently","Correct threading: 100%\nNo join: 80%\nWrong args: 70%\nNo threads: 50%","Not joining threads, wrong arguments, race conditions"
"Deadlock Prevention","C++","Implement lock ordering to prevent deadlock","class BankAccount {\n    mutex m;\n    int balance;\npublic:\n    void transfer(BankAccount& to, int amount) {\n        lock(m, to.m);\n        lock_guard<mutex> lock1(m, adopt_lock);\n        lock_guard<mutex> lock2(to.m, adopt_lock);\n        balance -= amount;\n        to.balance += amount;\n    }\n};","Transfers money without deadlock","Transfer between accounts safely","Deadlock-free: 100%\nUsing lock: 95%\nDeadlock possible: 40%\nNo locking: 20%","Deadlock, wrong lock order, not using adopt_lock"
"Design Pattern - Singleton","Java","Implement thread-safe Singleton pattern","public class Singleton {\n    private static volatile Singleton instance;\n    \n    private Singleton() {}\n    \n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}","getInstance() returns same instance always","Multiple calls return same object","Double-checked locking: 100%\nEager initialization: 95%\nNot thread-safe: 60%\nNo singleton: 30%","Not thread-safe, multiple instances, missing volatile"
"Design Pattern - Factory","Python","Implement Factory pattern for shape creation","class Shape:\n    def draw(self):\n        pass\n\nclass Circle(Shape):\n    def draw(self):\n        return ""Drawing Circle""\n\nclass Square(Shape):\n    def draw(self):\n        return ""Drawing Square""\n\nclass ShapeFactory:\n    @staticmethod\n    def create_shape(shape_type):\n        if shape_type == ""circle"":\n            return Circle()\n        elif shape_type == ""square"":\n            return Square()\n        return None","ShapeFactory.create_shape('circle') returns Circle","'circle' -> Circle object\n'square' -> Square object","Factory pattern: 100%\nDirect instantiation: 70%\nNo abstraction: 50%\nWrong pattern: 40%","Direct object creation, no factory, missing abstraction"
"Design Pattern - Observer","Java","Implement Observer pattern for event notification","interface Observer {\n    void update(String message);\n}\n\nclass Subject {\n    private List<Observer> observers = new ArrayList<>();\n    \n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    \n    public void notifyObservers(String message) {\n        for (Observer observer : observers) {\n            observer.update(message);\n        }\n    }\n}","Subject notifies all attached observers","Observers receive notifications","Observer pattern: 100%\nPartial implementation: 80%\nNo notification: 50%\nWrong pattern: 40%","Not notifying observers, tight coupling, missing interface"
"Unit Testing","Python","Write unit tests for a calculator class","import unittest\n\nclass Calculator:\n    def add(self, a, b):\n        return a + b\n    \n    def divide(self, a, b):\n        if b == 0:\n            raise ValueError(""Cannot divide by zero"")\n        return a / b\n\nclass TestCalculator(unittest.TestCase):\n    def setUp(self):\n        self.calc = Calculator()\n    \n    def test_add(self):\n        self.assertEqual(self.calc.add(2, 3), 5)\n    \n    def test_divide_by_zero(self):\n        with self.assertRaises(ValueError):\n            self.calc.divide(5, 0)","Tests pass for all calculator operations","All tests pass","Comprehensive tests: 100%\nBasic tests: 80%\nNo edge cases: 60%\nNo tests: 20%","Missing edge cases, no exception tests, wrong assertions"
"JSON Parsing","JavaScript","Parse JSON and extract specific fields safely","function parseUserData(jsonString) {\n    try {\n        const data = JSON.parse(jsonString);\n        return {\n            name: data.name || 'Unknown',\n            email: data.email || 'No email',\n            age: data.age || 0\n        };\n    } catch (error) {\n        console.error('Invalid JSON:', error.message);\n        return null;\n    }\n}","parseUserData('{""name"":""John""}') returns object with defaults","{""name"":""John""} -> {name:'John', email:'No email', age:0}","Safe parsing: 100%\nNo error handling: 70%\nNo defaults: 60%\nWrong parsing: 40%","Not handling errors, missing try-catch, no defaults"
"Regular Expressions","Python","Validate email format using regex","import re\n\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\n    return re.match(pattern, email) is not None","is_valid_email('test@example.com') returns True","'test@example.com' -> True\n'invalid' -> False","Correct regex: 100%\nSimple regex: 80%\nNo validation: 50%\nWrong pattern: 40%","Wrong regex pattern, not handling edge cases, no validation"
"File I/O Operations","C","Read and write binary file safely","int copy_binary_file(const char* src, const char* dst) {\n    FILE *source = fopen(src, ""rb"");\n    if (!source) return -1;\n    \n    FILE *dest = fopen(dst, ""wb"");\n    if (!dest) {\n        fclose(source);\n        return -1;\n    }\n    \n    char buffer[4096];\n    size_t bytes;\n    while ((bytes = fread(buffer, 1, sizeof(buffer), source)) > 0) {\n        fwrite(buffer, 1, bytes, dest);\n    }\n    \n    fclose(source);\n    fclose(dest);\n    return 0;\n}","copy_binary_file copies file byte by byte","Copies file successfully","Binary mode correct: 100%\nText mode: 80%\nNo error handling: 50%\nResource leaks: 30%","Not closing files, wrong mode, missing error checks"
"Data Validation","Java","Validate and sanitize user input","public static String sanitizeInput(String input) {\n    if (input == null || input.isEmpty()) {\n        return """";\n    }\n    \n    // Remove dangerous characters\n    String cleaned = input.replaceAll(""[<>&\\""']\\"", """");\n    \n    // Trim and limit length\n    cleaned = cleaned.trim();\n    if (cleaned.length() > 255) {\n        cleaned = cleaned.substring(0, 255);\n    }\n    \n    return cleaned;\n}","sanitizeInput('<script>') returns empty or safe string","'<script>' -> ''\n'normal text' -> 'normal text'","Full sanitization: 100%\nPartial cleaning: 80%\nNo validation: 40%\nInjection vulnerable: 20%","SQL injection, XSS vulnerable, no sanitization"
"Algorithm - Dijkstra","Python","Implement Dijkstra's shortest path algorithm","import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        \n        if current_dist > distances[current]:\n            continue\n        \n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances","dijkstra(graph, 'A') returns shortest distances","Returns dict of shortest paths from start","Correct Dijkstra: 100%\nBellman-Ford: 85%\nBFS without weights: 60%\nWrong algorithm: 40%","Not using priority queue, wrong algorithm, infinite loops"
"Data Structure - Trie","C++","Implement Trie for string storage and search","class TrieNode {\npublic:\n    map<char, TrieNode*> children;\n    bool isEndOfWord;\n    TrieNode() : isEndOfWord(false) {}\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\npublic:\n    Trie() { root = new TrieNode(); }\n    \n    void insert(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c])\n                node->children[c] = new TrieNode();\n            node = node->children[c];\n        }\n        node->isEndOfWord = true;\n    }\n    \n    bool search(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c]) return false;\n            node = node->children[c];\n        }\n        return node->isEndOfWord;\n    }\n};","insert('cat'), search('cat') returns true","'cat' inserted, search('cat') -> true\nsearch('ca') -> false","Correct Trie: 100%\nMinor issues: 90%\nWrong structure: 60%\nNo implementation: 30%","Memory leaks, wrong structure, not marking end of word"
"Bit Manipulation","Java","Check if a number is power of 2 using bitwise operations","public static boolean isPowerOfTwo(int n) {\n    return n > 0 && (n & (n - 1)) == 0;\n}","isPowerOfTwo(8) returns true, isPowerOfTwo(6) returns false","8 -> true\n6 -> false\n1 -> true","Bitwise solution: 100%\nMath solution: 80%\nLoop solution: 70%\nWrong logic: 40%","Not handling negative, wrong bitwise operation, using inefficient method"
"Network Programming","Python","Create a simple TCP socket server","import socket\n\ndef start_server(host='127.0.0.1', port=8080):\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind((host, port))\n    server.listen(5)\n    print(f""Server listening on {host}:{port}"")\n    \n    while True:\n        client, addr = server.accept()\n        print(f""Connection from {addr}"")\n        data = client.recv(1024)\n        client.send(b""Message received"")\n        client.close()","Server accepts connections and responds","Accepts and responds to clients","Correct socket: 100%\nNo error handling: 80%\nUDP instead: 60%\nWrong protocol: 40%","Not binding, wrong socket type, not listening"
"Security - SQL Injection Prevention","Python","Use parameterized queries to prevent SQL injection","import sqlite3\n\ndef get_user_safe(username):\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    \n    # Safe: using parameterized query\n    query = ""SELECT * FROM users WHERE username = ?""\n    cursor.execute(query, (username,))\n    \n    result = cursor.fetchone()\n    conn.close()\n    return result","get_user_safe('admin') safely queries database","'admin' -> user data\n'admin' OR '1'='1' -> no injection","Parameterized query: 100%\nString formatting: 30%\nDirect concatenation: 10%","SQL injection vulnerable, string concatenation, no parameterization"
"Caching Strategy","Java","Implement LRU cache with get and put operations","class LRUCache {\n    private final int capacity;\n    private final LinkedHashMap<Integer, Integer> cache;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.cache = new LinkedHashMap<>(capacity, 0.75f, true) {\n            protected boolean removeEldestEntry(Map.Entry eldest) {\n                return size() > capacity;\n            }\n        };\n    }\n    \n    public int get(int key) {\n        return cache.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        cache.put(key, value);\n    }\n}","LRU cache evicts least recently used items","capacity=2: put(1,1),put(2,2),get(1),put(3,3) -> evicts 2","LRU implemented: 100%\nHashMap only: 70%\nNo eviction: 50%\nWrong order: 40%","Not tracking access order, no eviction, wrong data structure"
"Asynchronous Programming","JavaScript","Implement async/await for API calls","async function fetchUserData(userId) {\n    try {\n        const response = await fetch(`/api/users/${userId}`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error('Error fetching user:', error);\n        return null;\n    }\n}","fetchUserData(1) returns user data asynchronously","Returns user data or handles errors","Async/await: 100%\nPromises: 90%\nCallbacks: 70%\nNo error handling: 50%","Not handling errors, callback hell, blocking operations"
"Memory Profiling","C","Detect and fix memory leaks","void process_data() {\n    int* data = (int*)malloc(100 * sizeof(int));\n    if (!data) {\n        fprintf(stderr, ""Memory allocation failed\n"");\n        return;\n    }\n    \n    // Process data\n    for (int i = 0; i < 100; i++) {\n        data[i] = i * 2;\n    }\n    \n    // CRITICAL: Free memory\n    free(data);\n}","Allocates, uses, and properly frees memory","No memory leaks","Proper free: 100%\nMissing free: 30%\nDouble free: 20%","Memory leaks, double free, use after free"
"Web Scraping","Python","Safely scrape web content with error handling","import requests\nfrom bs4 import BeautifulSoup\n\ndef scrape_title(url):\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        \n        soup = BeautifulSoup(response.content, 'html.parser')\n        title = soup.find('title')\n        return title.text if title else 'No title found'\n    \n    except requests.RequestException as e:\n        print(f""Error scraping {url}: {e}"")\n        return None","scrape_title('https://example.com') returns page title","Returns page title or handles errors","Error handling: 100%\nNo timeout: 80%\nNo exception handling: 50%","Timeout issues, no error handling, not checking status"